<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://sbmueller.de/ name=base><title>
            
                Interfacing with Rust from C/C++
            
        </title><meta content="Interfacing with Rust from C/C++" property=og:title><link href=https://sbmueller.de/icon/favicon.png rel=icon type=image/png><link href=https://sbmueller.de/fonts.css rel=stylesheet><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://sbmueller.de/theme/light.css rel=stylesheet><link href=https://sbmueller.de/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://sbmueller.de/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://sbmueller.de/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><style>.avatar{vertical-align:middle;border-radius:50%;max-width:150px;height:auto}#wrapper{clear:both;text-align:center;width:100%}</style><nav><div class=left-nav><a href=https://sbmueller.de/>sbmueller</a><div class=socials><a class=social href=https://github.com/sbmueller/ rel=me> <img alt=github src=https://sbmueller.de/icons/social/github.svg> </a><a class=social href=https://www.linkedin.com/in/sbmueller/ rel=me> <img alt=linkedin src=https://sbmueller.de/icons/social/linkedin.svg> </a></div></div><div class=right-nav><a href=https://sbmueller.de/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://sbmueller.de/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://sbmueller.de/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div id=wrapper><a href=https://sbmueller.de/> <img src="https://avatars.githubusercontent.com/u/7465688?v=4" class=avatar> </a></div><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Interfacing with Rust from C/C++</div><div class=meta>Posted on <time>2023-08-16</time></div></div><section class=body><p>The Rust programming language is considered as one of the potential successors for C++ when it comes to systems programming. A reasonable first step, when adapting to a new language, is replacing small parts of a system while the remaining parts are maintained in the former language.<p>To achieve this, an interoperability between the new and old language needs to be established. In the following, I will describe how to implement a dynamic Rust library that exposes its interface to C/C++.<h2 id=make-a-rust-library-accessible-from-c-c>Make a Rust library accessible from C/C++</h2><p>Assume working in a cargo directory that was created e.g. by<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=plain><span class=giallo-l><span>cargo new --lib mylib</span></span></code></pre><h3 id=use-the-ffi>Use the FFI</h3><p>Rust relies on the Foreign Function Interface (FFI) to interface with other languages. The FFI mainly targets C as language.<p>To make functions in Rust code accessible via the FFI, they need to be externalized and declared as <code>no_mangle</code>:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=rust><span class=giallo-l><span style=color:#908caa;font-style:italic>//</span><span style=color:#6e6a86;font-style:italic> src/lib.rs</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#908caa>#[</span><span>no_mangle</span><span style=color:#908caa>]</span></span>
<span class=giallo-l><span style=color:#3e8fb0>pub extern</span><span style=color:#f6c177> "C"</span><span style=color:#3e8fb0> fn</span><span style=color:#ea9a97> add</span><span style=color:#908caa>(</span><span style=font-style:italic>a</span><span style=color:#3e8fb0>:</span><span style=color:#9ccfd8> i32</span><span style=color:#908caa>,</span><span style=font-style:italic> b</span><span style=color:#3e8fb0>:</span><span style=color:#9ccfd8> i32</span><span style=color:#908caa>)</span><span style=color:#3e8fb0> -></span><span style=color:#9ccfd8> i32</span><span style=color:#908caa> {</span></span>
<span class=giallo-l><span style=font-style:italic>    a</span><span style=color:#3e8fb0> +</span><span style=font-style:italic> b</span></span>
<span class=giallo-l><span style=color:#908caa>}</span></span></code></pre><ul><li><code>extern "C"</code> ensures the C ABI is used for calling functions in shared libraries<li><code>#[no_mangle]</code> ensures the function names don't experience <a href=https://en.wikipedia.org/wiki/Name_mangling rel=external>mangling</a></ul><p>Both conditions must be fulfilled to enable interfacing via this function using the FFI.<h3 id=build-a-dynamic-library>Build a dynamic library</h3><p>By default, cargo does <a href=https://doc.rust-lang.org/reference/linkage.html#linkage rel=external>not build dynamic system libraries</a>. To generate a dynamic library (.dylib on Mac, .so in Linux and .dll on Windows), the <code>Cargo.toml</code> has to be extended by:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=toml><span class=giallo-l><span style=color:#908caa;font-style:italic>#</span><span style=color:#6e6a86;font-style:italic> Cargo.toml</span></span>
<span class=giallo-l><span style=color:#908caa>[</span><span style=color:#9ccfd8>lib</span><span style=color:#908caa>]</span></span>
<span class=giallo-l><span style=font-style:italic>crate-type</span><span style=color:#908caa>   = [</span><span style=color:#f6c177>"cdylib"</span><span style=color:#908caa>]</span></span></code></pre><p>This ensures <code>rustc</code> actually compiles a dynamic library.<h3 id=generate-a-c-c-header-file>Generate a C/C++ header file</h3><p>To access functions in third-party libraries, C/C++ code needs to include a header file that declares the interface towards the library.<p>The header file can be written and maintained by hand, or be generated automatically by using <code>cbindgen</code>. Add <code>cbindgen</code> to the build dependencies in <code>Cargo.toml</code>:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=toml><span class=giallo-l><span style=color:#908caa;font-style:italic>#</span><span style=color:#6e6a86;font-style:italic> Cargo.toml</span></span>
<span class=giallo-l><span style=color:#908caa>[</span><span style=color:#9ccfd8>build-dependencies</span><span style=color:#908caa>]</span></span>
<span class=giallo-l><span style=font-style:italic>cbindgen</span><span style=color:#908caa> =</span><span style=color:#f6c177> "0.24.3"</span></span></code></pre><p>And place a custom <code>build.rs</code> file in the project root with the following content:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=rust><span class=giallo-l><span style=color:#908caa;font-style:italic>//</span><span style=color:#6e6a86;font-style:italic> build.rs</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>extern crate cbindgen</span><span style=color:#908caa>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>use</span><span style=color:#9ccfd8> std</span><span style=color:#3e8fb0>::</span><span>env</span><span style=color:#908caa>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>fn</span><span style=color:#ea9a97> main</span><span style=color:#908caa>() {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    let</span><span style=font-style:italic> crate_dir</span><span style=color:#3e8fb0> =</span><span style=color:#9ccfd8> env</span><span style=color:#3e8fb0>::</span><span style=color:#ea9a97>var</span><span style=color:#908caa>(</span><span style=color:#f6c177>"CARGO_MANIFEST_DIR"</span><span style=color:#908caa>)</span><span style=color:#3e8fb0>.</span><span style=color:#ea9a97>unwrap</span><span style=color:#908caa>();</span></span>
<span class=giallo-l><span style=color:#ea9a97>    println!</span><span style=color:#908caa>(</span><span style=color:#f6c177>"Generating C/C++ header"</span><span style=color:#908caa>);</span></span>
<span class=giallo-l><span style=color:#9ccfd8>    cbindgen</span><span style=color:#3e8fb0>::</span><span style=color:#9ccfd8>Builder</span><span style=color:#3e8fb0>::</span><span style=color:#ea9a97>new</span><span style=color:#908caa>()</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      .</span><span style=color:#ea9a97>with_crate</span><span style=color:#908caa>(</span><span style=font-style:italic>crate_dir</span><span style=color:#908caa>)</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      .</span><span style=color:#ea9a97>generate</span><span style=color:#908caa>()</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      .</span><span style=color:#ea9a97>expect</span><span style=color:#908caa>(</span><span style=color:#f6c177>"Unable to generate bindings"</span><span style=color:#908caa>)</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      .</span><span style=color:#ea9a97>write_to_file</span><span style=color:#908caa>(</span><span style=color:#f6c177>"include/mylib.h"</span><span style=color:#908caa>);</span></span>
<span class=giallo-l><span style=color:#908caa>}</span></span></code></pre><p>This will ensure when calling <code>cargo build</code>, <code>cbindgen</code> is used to auto-generate a C/C++ header file that declares the interface of the Rust library.<p>After invoking <code>cargo build --release</code>, the generated header looks like this:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=cpp><span class=giallo-l><span style=color:#908caa;font-style:italic>//</span><span style=color:#6e6a86;font-style:italic> include/mylib.h</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;cstdarg></span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;cstdint></span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;cstdlib></span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;ostream></span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;new></span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>extern</span><span style=color:#f6c177> "C"</span><span style=color:#908caa> {</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>int32_t</span><span style=color:#ea9a97> add</span><span style=color:#908caa>(</span><span style=color:#3e8fb0>int32_t</span><span style=color:#c4a7e7;font-style:italic> a</span><span style=color:#908caa>,</span><span style=color:#3e8fb0> int32_t</span><span style=color:#c4a7e7;font-style:italic> b</span><span style=color:#908caa>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#908caa>}</span><span style=color:#908caa;font-style:italic> //</span><span style=color:#6e6a86;font-style:italic> extern "C"</span></span></code></pre><h2 id=building-the-c-project>Building the C++ project</h2><p>Assume we want to use the Rust library in a C++ project:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=cpp><span class=giallo-l><span style=color:#908caa;font-style:italic>//</span><span style=color:#6e6a86;font-style:italic> main.cpp</span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;add_rs.h></span></span>
<span class=giallo-l><span style=color:#908caa>#</span><span style=color:#3e8fb0>include</span><span style=color:#f6c177> &lt;iostream></span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#3e8fb0>int</span><span style=color:#ea9a97> main</span><span style=color:#908caa>()</span></span>
<span class=giallo-l><span style=color:#908caa>{</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    int</span><span> result </span><span style=color:#3e8fb0>=</span><span style=color:#ea9a97> add</span><span style=color:#908caa>(</span><span style=color:#ea9a97>3</span><span style=color:#908caa>,</span><span style=color:#ea9a97> 5</span><span style=color:#908caa>);</span><span style=color:#908caa;font-style:italic> //</span><span style=color:#6e6a86;font-style:italic> `add` is implemented in Rust!</span></span>
<span class=giallo-l><span style=color:#ea9a97>    std</span><span style=color:#908caa>::</span><span>cout </span><span style=color:#3e8fb0>&lt;&lt;</span><span style=color:#f6c177> "Result: "</span><span style=color:#3e8fb0> &lt;&lt;</span><span> result </span><span style=color:#3e8fb0>&lt;&lt;</span><span style=color:#ea9a97> std</span><span style=color:#908caa>::</span><span>endl</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    return</span><span style=color:#ea9a97> 0</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#908caa>}</span></span></code></pre><p>To compile this project with GCC, e.g. use:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=plain><span class=giallo-l><span>g++ main.cpp -o add -Imylib/include -Lmylib/target/release/ -ladd_rs</span></span></code></pre><p>Now, if you execute the program, the C++ program will interface with the library written in Rust using a C interface to calculate the desired result:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=plain><span class=giallo-l><span>Result: 8</span></span></code></pre><p>If you want to see a comprehensive proof on concept using Conan instead of plain GCC, you can find that on my <a href=https://github.com/sbmueller/rust-conan-template rel=external>GitHub</a>.</section></article></main></div><hr><center><small>Copyright © 2026 Sebastian Müller. All rights reserved.</small></center></div><div class=right-content></div>