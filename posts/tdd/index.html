<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://sbmueller.github.io/ name=base><title>
            
                Test Driven Development in Rust and Python
            
        </title><meta content="Test Driven Development in Rust and Python" property=og:title><link href=https://sbmueller.github.io/icon/favicon.png rel=icon type=image/png><link href=https://sbmueller.github.io/fonts.css rel=stylesheet><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://sbmueller.github.io/theme/light.css rel=stylesheet><link href=https://sbmueller.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://sbmueller.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://sbmueller.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><style>.avatar{vertical-align:middle;border-radius:50%;max-width:150px;height:auto}#wrapper{clear:both;text-align:center;width:100%}</style><nav><div class=left-nav><a href=https://sbmueller.github.io/>sbmueller</a><div class=socials><a class=social href=https://github.com/sbmueller/ rel=me> <img alt=github src=https://sbmueller.github.io/icons/social/github.svg> </a><a class=social href=https://www.linkedin.com/in/sbmueller/ rel=me> <img alt=linkedin src=https://sbmueller.github.io/icons/social/linkedin.svg> </a></div></div><div class=right-nav><a href=https://sbmueller.github.io/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://sbmueller.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://sbmueller.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div id=wrapper><a href=https://sbmueller.github.io/> <img src="https://avatars.githubusercontent.com/u/7465688?v=4" class=avatar> </a></div><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Test Driven Development in Rust and Python</div><div class=meta>Posted on <time>2023-03-11</time></div></div><section class=body><p>Test Driven Development (TDD) is a common best practice when developing software. The idea behind it is to write the unit tests for the software before and during development, instead of afterwards. It has empirically been observed that this leads to shorter development times and less defects in the software.<p>A common method for TDD is "Red-Green-Refactor". This method consists of a cycle of three steps:<ol><li>Write a test that covers an aspect of the software you want to develop. If you run the test, it will fail (Red). Notice that also compilation and runtime errors should be considered failure.<li>Next, write enough business logic to make your test pass (green). Do not write anything else, focus on the small increments.<li>(If applicable) refactor and apply best practices to iterate to a mature solution.</ol><p>Repeat until your feature set is completely tested and implemented.<h2 id=test-driven-development-in-rust>Test Driven Development in Rust</h2><p>Rust has a convention that makes it particularly easy to practice TDD: The unit tests are usually located in the same file as the business logic. This avoid constant switching between files during TDD development, but also supports during software maintenance, e.g. writing a regression test for a bug-fix.<p>For this example, I'm using the <a href=https://www.hackerrank.com/challenges/ctci-bubble-sort/problem>bubble sort problem</a> from Hackerrank.<p>The boilerplate code in Rust looks like this:<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>use </span><span>std::io::{</span><span style=color:#e06c75>self</span><span>, BufRead};
</span><span>
</span><span style=color:#5c6370;font-style:italic>/*
</span><span style=color:#5c6370;font-style:italic> * Complete the 'count_swaps' function below.
</span><span style=color:#5c6370;font-style:italic> *
</span><span style=color:#5c6370;font-style:italic> * The function accepts INTEGER_ARRAY a as parameter.
</span><span style=color:#5c6370;font-style:italic> */
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>count_swaps</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) {
</span><span>
</span><span>}
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>main</span><span>() {
</span><span>    </span><span style=color:#c678dd>let</span><span> stdin = io::stdin();
</span><span>    </span><span style=color:#c678dd>let mut</span><span> stdin_iterator = stdin.</span><span style=color:#56b6c2>lock</span><span>().</span><span style=color:#56b6c2>lines</span><span>();
</span><span>
</span><span>    </span><span style=color:#c678dd>let</span><span> n = stdin_iterator.</span><span style=color:#56b6c2>next</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>().</span><span style=color:#56b6c2>trim</span><span>().parse::<</span><span style=color:#c678dd>i32</span><span>>().</span><span style=color:#56b6c2>unwrap</span><span>();
</span><span>
</span><span>    </span><span style=color:#c678dd>let</span><span> a: Vec<</span><span style=color:#c678dd>i32</span><span>> = stdin_iterator.</span><span style=color:#56b6c2>next</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>()
</span><span>        .</span><span style=color:#56b6c2>trim_end</span><span>()
</span><span>        .</span><span style=color:#56b6c2>split</span><span>(</span><span style=color:#98c379>' '</span><span>)
</span><span>        .</span><span style=color:#56b6c2>map</span><span>(|</span><span style=color:#e06c75>s</span><span>| s.</span><span style=color:#56b6c2>to_string</span><span>().parse::<</span><span style=color:#c678dd>i32</span><span>>().</span><span style=color:#56b6c2>unwrap</span><span>())
</span><span>        .</span><span style=color:#56b6c2>collect</span><span>();
</span><span>
</span><span>    </span><span style=color:#56b6c2>count_swaps</span><span>(&a);
</span><span>}
</span></code></pre><p>In the following, I will omit the <code>main</code> method, which just reads the <code>stdin</code> input.<h3 id=red-phase>Red Phase</h3><p>To start with TDD, we need to write any test cases at all. For Hackerrank, I usually use the provided examples and sample tests. The example tells, for a given input of <code>[6,4,1]</code>, the output of the program shall be<pre style=color:#abb2bf;background-color:#282c34><code><span>Array is sorted in 3 swaps.
</span><span>First Element: 1
</span><span>Last Element: 6
</span></code></pre><p>So let's try to input that into an unit test. Note that due to the small scope of Hackerrank exercises, this test already covers the whole business logic. In a real world application, this can (and should) be a much smaller scope.<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>fn </span><span style=color:#61afef>count_swaps</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) {
</span><span>
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#e06c75>cfg</span><span>(test)]
</span><span style=color:#c678dd>mod </span><span>tests {
</span><span>    </span><span style=color:#c678dd>use super</span><span>::*;
</span><span>
</span><span>    #[</span><span style=color:#e06c75>test</span><span>]
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>example</span><span>() {
</span><span>        </span><span style=color:#c678dd>let</span><span> output = </span><span style=color:#56b6c2>count_swaps</span><span>(&[</span><span style=color:#d19a66>6</span><span>, </span><span style=color:#d19a66>4</span><span>, </span><span style=color:#d19a66>1</span><span>]);
</span><span>    }
</span><span>}
</span></code></pre><p>First we create a module named <code>test</code> for a test configuration, meaning it will only be compiled when we explicitly run the tests via <code>cargo test</code>. Within the module, all entities from the outer scope are imported. Lastly, a test function <code>example</code> is created.<p>But wait, our program takes an array as input, but is required to print to <code>stdout</code> as output. How to test that? The solution to this problem is to refactor and extract the business logic to make it testable independently:<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>business_logic</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) -> (</span><span style=color:#c678dd>usize</span><span>, </span><span style=color:#c678dd>i32</span><span>, </span><span style=color:#c678dd>i32</span><span>) {
</span><span>
</span><span>}
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>count_swaps</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) {
</span><span>
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#e06c75>cfg</span><span>(test)]
</span><span style=color:#c678dd>mod </span><span>tests {
</span><span>    </span><span style=color:#c678dd>use super</span><span>::*;
</span><span>
</span><span>    #[</span><span style=color:#e06c75>test</span><span>]
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>example</span><span>() {
</span><span>        assert_eq!(</span><span style=color:#56b6c2>business_logic</span><span>(&[</span><span style=color:#d19a66>6</span><span>, </span><span style=color:#d19a66>4</span><span>, </span><span style=color:#d19a66>1</span><span>], (</span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>6</span><span>));
</span><span>    }
</span><span>}
</span></code></pre><p>We created a testable method <code>business_logic</code> that returns the three values that should be outputted. With that design, the logic becomes easily testable. Also, we introduced an assertion into our test method, that check equality of the output of <code>business_logic</code> and the provided example solution. Now we can run <code>cargo test</code> and ... experience a compilation error: <code>error[E0308]: mismatched types</code>. This is the "Red" phase of our TDD method, so we're on the right way. Next, let's move to the Green phase and resolve our issue.<h3 id=green-phase>Green Phase</h3><p>To resolve the error we are facing, we need to provide a function body for <code>business_logic</code> that returns a value matching the function signature. We can easily do this:<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>fn </span><span style=color:#61afef>business_logic</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) -> (</span><span style=color:#c678dd>usize</span><span>, </span><span style=color:#c678dd>i32</span><span>, </span><span style=color:#c678dd>i32</span><span>) {
</span><span>    (</span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>6</span><span>)
</span><span>}
</span></code></pre><p>Now, we can run <code>cargo test</code> and we can see that the test succeeds. Green phase completed. At this point, we don't need to refactor and can directly move to the next Red phase.<h3 id=red-phase-1>Red Phase</h3><p>Since it worked so well, we can now implement a second test that checks another provided solution:<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span>    #[</span><span style=color:#e06c75>test</span><span>]
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>example</span><span>() {
</span><span>        assert_eq!(</span><span style=color:#56b6c2>business_logic</span><span>(&[</span><span style=color:#d19a66>6</span><span>, </span><span style=color:#d19a66>4</span><span>, </span><span style=color:#d19a66>1</span><span>], (</span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>6</span><span>));
</span><span>    }
</span><span>
</span><span>    #[</span><span style=color:#e06c75>test</span><span>]
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>sample_test_case_0</span><span>() {
</span><span>        assert_eq!(</span><span style=color:#56b6c2>business_logic</span><span>(&[</span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>2</span><span>, </span><span style=color:#d19a66>3</span><span>]), (</span><span style=color:#d19a66>0</span><span>, </span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>3</span><span>));
</span><span>    }
</span></code></pre><p>Running <code>cargo test</code> now shows us that something doesn't work as intended: <code>thread 'tests::sample_test_case_0' panicked at 'assertion failed: (left == right)</code>. At this point, we should probably start thinking about a proper business logic that solves our problem statement, as <code>(3, 1, 6)</code> will not always be the answer we're searching.<h3 id=green-phase-1>Green Phase</h3><p>While repeating this pattern for a while, eventually we come up with the following code:<pre class=language-rust data-lang=rust style=color:#abb2bf;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>fn </span><span style=color:#61afef>business_logic</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) -> (</span><span style=color:#c678dd>usize</span><span>, </span><span style=color:#c678dd>i32</span><span>, </span><span style=color:#c678dd>i32</span><span>) {
</span><span>    </span><span style=color:#c678dd>let mut</span><span> swaps = </span><span style=color:#d19a66>0</span><span>;
</span><span>    </span><span style=color:#c678dd>let mut</span><span> a_vec = a.</span><span style=color:#56b6c2>to_vec</span><span>();
</span><span>    </span><span style=color:#c678dd>for </span><span>_ in </span><span style=color:#d19a66>0</span><span>..a_vec.</span><span style=color:#56b6c2>len</span><span>() {
</span><span>        </span><span style=color:#c678dd>for</span><span> j in </span><span style=color:#d19a66>0</span><span>..a_vec.</span><span style=color:#56b6c2>len</span><span>() - </span><span style=color:#d19a66>1 </span><span>{
</span><span>            </span><span style=color:#c678dd>if</span><span> a_vec[j] > a_vec[j + </span><span style=color:#d19a66>1</span><span>] {
</span><span>                a_vec.</span><span style=color:#56b6c2>swap</span><span>(j, j + </span><span style=color:#d19a66>1</span><span>);
</span><span>                swaps += </span><span style=color:#d19a66>1</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    (swaps, *a_vec.</span><span style=color:#56b6c2>first</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>(), *a_vec.</span><span style=color:#56b6c2>last</span><span>().</span><span style=color:#56b6c2>unwrap</span><span>())
</span><span>}
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>count_swaps</span><span>(</span><span style=color:#e06c75>a</span><span>: &[</span><span style=color:#c678dd>i32</span><span>]) {
</span><span>    </span><span style=color:#c678dd>let </span><span>(swaps, min, max) = </span><span style=color:#56b6c2>business_logic</span><span>(a);
</span><span>    println!(</span><span style=color:#98c379>"Array is sorted in </span><span style=color:#d19a66>{swaps}</span><span style=color:#98c379> swaps."</span><span>);
</span><span>    println!(</span><span style=color:#98c379>"First Element: </span><span style=color:#d19a66>{min}</span><span style=color:#98c379>"</span><span>);
</span><span>    println!(</span><span style=color:#98c379>"Last Element: </span><span style=color:#d19a66>{max}</span><span style=color:#98c379>"</span><span>);
</span><span>}
</span></code></pre><p>That is one of probably multiple solutions to the problem statement, and we iterated to it using TDD! Also note that, in order to fulfill the requirements of the task, the output should be printed to <code>stdout</code>, which is done in the function <code>count_swaps</code> which serves as entry point for the main logic. That function just calls our internal <code>business_logic</code> and prints the results.<p>This is a small example how to do TDD in Rust. Again, please note that the scope was rather small and therefore almost no refactoring was necessary. In bigger applications, it is usual to test different aspects of a program and iterate and refactor until the requirements are met.<h2 id=test-driven-development-in-python>Test Driven Development in Python</h2><p>TDD in Python can be done quite similar as in Rust. It is even possible, though not as much of a convention as in Rust, to write unit tests in the same file, next to the business logic. As I mentioned above, I like that approach.<p>Unlike Rust, there is not one solution to implement and run tests provided by the ecosystem (namely <code>cargo test</code>), though Python offers different modules that can be used. Here, we're relying on <code>unittest</code>. An example how to write unit tests could look like this:<pre class=language-python data-lang=python style=color:#abb2bf;background-color:#282c34><code class=language-python data-lang=python><span style=color:#c678dd>import </span><span>unittest
</span><span>
</span><span style=color:#c678dd>def </span><span style=color:#61afef>business_logic</span><span>(</span><span style=color:#e06c75>a</span><span>: List[int]) -> (int, int, int):
</span><span>    [</span><span style=color:#d19a66>...</span><span>]
</span><span>
</span><span style=color:#c678dd>class </span><span style=color:#e5c07b>BubbleSortTest</span><span>(</span><span style=color:#98c379>unittest.TestCase</span><span>):
</span><span>    </span><span style=color:#c678dd>def </span><span style=color:#61afef>test_example</span><span>(</span><span style=color:#e06c75>self</span><span>):
</span><span>        </span><span style=color:#e06c75>self</span><span>.</span><span style=color:#e06c75>assertEqual</span><span>(</span><span style=color:#e06c75>business_logic</span><span>([</span><span style=color:#d19a66>6</span><span>, </span><span style=color:#d19a66>4</span><span>, </span><span style=color:#d19a66>1</span><span>]), (</span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>6</span><span>))
</span></code></pre><p>Firstly, we have to import the <code>unittest</code> module to use it. Then, we declare a class which inherits from <code>unittest.TestCase</code>. Within that class, we write methods that serve as our unit tests. Note that test method names must always start with <code>test</code>, else they won't get executed as part of the unit test. That way, you can implement helpers in the test class that won't be executed standalone. To run the unit tests, execute: <code>python3 -m unittest bubble_sort.py</code>, which is the equivalent of <code>cargo test</code> in Rust.</section></article></main></div><hr><center><small>Copyright © 2025 Sebastian Müller. All rights reserved.</small></center></div><div class=right-content></div>