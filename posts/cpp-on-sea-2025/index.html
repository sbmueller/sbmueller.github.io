<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://sbmueller.de/ name=base><title>
            
                C++ On Sea 2025 Takeaways
            
        </title><meta content="C++ On Sea 2025 Takeaways" property=og:title><link href=https://sbmueller.de/icon/favicon.png rel=icon type=image/png><link href=https://sbmueller.de/fonts.css rel=stylesheet><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://sbmueller.de/theme/light.css rel=stylesheet><link href=https://sbmueller.de/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://sbmueller.de/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://sbmueller.de/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><style>.avatar{vertical-align:middle;border-radius:50%;max-width:150px;height:auto}#wrapper{clear:both;text-align:center;width:100%}</style><nav><div class=left-nav><a href=https://sbmueller.de/>sbmueller</a><div class=socials><a class=social href=https://github.com/sbmueller/ rel=me> <img alt=github src=https://sbmueller.de/icons/social/github.svg> </a><a class=social href=https://www.linkedin.com/in/sbmueller/ rel=me> <img alt=linkedin src=https://sbmueller.de/icons/social/linkedin.svg> </a></div></div><div class=right-nav><a href=https://sbmueller.de/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://sbmueller.de/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://sbmueller.de/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div id=wrapper><a href=https://sbmueller.de/> <img src="https://avatars.githubusercontent.com/u/7465688?v=4" class=avatar> </a></div><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>C++ On Sea 2025 Takeaways</div><div class=meta>Posted on <time>2025-06-29</time></div></div><section class=body><p>Recently, I had the opportunity to join the <a href=https://cpponsea.uk/ rel=external>C++ on Sea</a> conference in Folkestone, UK. I had a wonderful time immersing myself further into the C++ world and learning both new concepts and ideas but also getting to know a lot of awesome people. Thanks to all the people that talked to me and made the conference a pleasure, specifically Matt, Jason, Hampus, Prithvi, Kathleen, Tina, Hendrik, Timur, Walter, Christopher, Vincent, Evgenii and all others I might have forgotten in this list (shame on me).<p>Now, I want to highlight my takeaways from the conference.<h2 id=error-handling-with-monads>Error Handling with Monads</h2><p>In his talk <a href=https://cpponsea.uk/2025/session/safe-and-readable-code-monadic-operations-in-cpp23 rel=external>Safe and Readable Code: Monadic Operations in C++23</a>, Robert Schimkowitsch introduced the power of using monadic operations in existing code. I enjoyed the side-by-side examples that highlighted the benefit over plain <code>if</code>-chains, that mix business logic and error handling logic.<p>Imagine a classic C++ (embedded) code that doesn't rely on exceptions. Often, we find something like this:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=cpp><span class=giallo-l><span style=color:#3e8fb0>bool</span><span> getIntCellValueNegative</span></span>
<span class=giallo-l><span style=color:#908caa>  (</span><span>CDb db</span><span style=color:#908caa>,</span><span> Key key</span><span style=color:#908caa>,</span><span> CLocation location</span><span style=color:#908caa>,</span><span style=color:#3e8fb0> bool &</span><span> result</span><span style=color:#908caa>) {</span></span>
<span class=giallo-l><span>    CElement element</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    if</span><span style=color:#908caa> (</span><span style=color:#3e8fb0>!</span><span style=color:#ea9a97>getElement</span><span style=color:#908caa>(</span><span>db</span><span style=color:#908caa>,</span><span> key</span><span style=color:#908caa>,</span><span> element</span><span style=color:#908caa>)) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      return</span><span style=color:#ea9a97> false</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#908caa>    }</span></span>
<span class=giallo-l><span>    CTable table</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    if</span><span style=color:#908caa> (</span><span style=color:#3e8fb0>!</span><span style=color:#ea9a97>getTable</span><span style=color:#908caa>(</span><span>element</span><span style=color:#908caa>,</span><span> table</span><span style=color:#908caa>)) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      return</span><span style=color:#ea9a97> false</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#908caa>    }</span></span>
<span class=giallo-l><span>    CCell cell</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    if</span><span style=color:#908caa> (</span><span style=color:#3e8fb0>!</span><span style=color:#ea9a97>getCell</span><span style=color:#908caa>(</span><span>table</span><span style=color:#908caa>,</span><span> location</span><span style=color:#908caa>,</span><span> cell</span><span style=color:#908caa>)) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      return</span><span style=color:#ea9a97> false</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#908caa>    }</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    int</span><span> value</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    if</span><span style=color:#908caa> (</span><span style=color:#3e8fb0>!</span><span style=color:#ea9a97>getNumericCellValue</span><span style=color:#908caa>(</span><span>cell</span><span style=color:#908caa>,</span><span> value</span><span style=color:#908caa>)) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      return</span><span style=color:#ea9a97> false</span><span style=color:#908caa>;</span></span>
<span class=giallo-l><span style=color:#908caa>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    result </span><span style=color:#3e8fb0>=</span><span style=color:#908caa> (</span><span>value </span><span style=color:#3e8fb0>&lt;</span><span style=color:#ea9a97> 0</span><span style=color:#908caa>);</span></span>
<span class=giallo-l><span style=color:#3e8fb0>    return</span><span style=color:#ea9a97> true</span><span style=color:#908caa>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#908caa>  }</span></span></code></pre><p>This approach uses a return value based error handling (<code>false</code> in case of failure, <code>true</code> otherwise). The error handling logic is deeply entangled with the business logic, making the function unnecessary long and difficult to understand.<p>A monad is a design pattern used in functional programming that helps chain operations while handling context (like absence of a value, errors, or asynchronous computations). It’s a wrapper that lets you compose a series of operations without repeatedly checking the context (e.g., whether a value is present or not). A more modern approach to this functionality is the use of <code>std::optional</code> as monad:<pre class=giallo style=color:#e0def4;background-color:#232136><code data-lang=cpp><span class=giallo-l><span style=color:#9ccfd8>optional</span><span style=color:#908caa>&lt;</span><span style=color:#3e8fb0>bool</span><span style=color:#908caa>></span><span style=color:#ea9a97> isIntCellValueNegative</span><span style=color:#908caa>(</span><span style=color:#9ccfd8>CDb</span><span style=color:#c4a7e7;font-style:italic> db</span><span style=color:#908caa>,</span><span style=color:#9ccfd8> Key</span><span style=color:#c4a7e7;font-style:italic> key</span><span style=color:#908caa>,</span><span style=color:#9ccfd8> CLocation</span><span style=color:#c4a7e7;font-style:italic> location</span><span style=color:#908caa>) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>  return</span><span style=color:#ea9a97> getElement</span><span style=color:#908caa>(</span><span>db</span><span style=color:#908caa>,</span><span> key</span><span style=color:#908caa>)</span></span>
<span class=giallo-l><span>    .</span><span style=color:#ea9a97>and_then</span><span style=color:#908caa>(</span><span>getTable</span><span style=color:#908caa>)</span></span>
<span class=giallo-l><span>    .</span><span style=color:#ea9a97>and_then</span><span style=color:#908caa>([</span><span style=color:#c4a7e7;font-style:italic>location</span><span style=color:#908caa>](</span><span style=color:#9ccfd8>CTable</span><span style=color:#c4a7e7;font-style:italic> table</span><span style=color:#908caa>) {</span></span>
<span class=giallo-l><span style=color:#3e8fb0>      return</span><span style=color:#ea9a97> getCell</span><span style=color:#908caa>(</span><span>table</span><span style=color:#908caa>,</span><span> location</span><span style=color:#908caa>);</span></span>
<span class=giallo-l><span style=color:#908caa>    })</span></span>
<span class=giallo-l><span>    .</span><span style=color:#ea9a97>and_then</span><span style=color:#908caa>(</span><span>getNumericCellValue</span><span style=color:#908caa>)</span></span>
<span class=giallo-l><span>    .</span><span style=color:#ea9a97>transform</span><span style=color:#908caa>(</span><span>isNegative</span><span style=color:#908caa>);</span></span>
<span class=giallo-l><span style=color:#908caa>}</span></span></code></pre><p>The <code>transform</code> function is typical for functors. It maps one type <code>T</code> to another one <code>U</code>, or does nothing if no value is contained in the <code>optional</code>. <code>and_then</code> is typical for monads, as it takes a transformation function that has the content of the <code>optional</code> <code>T</code> as input and returns another <code>optional&lt;U></code> with a transformed type. Note that no specific code needs to be written to handle the both cases that the <code>optional</code> can contain a value or be empty.<p>At this point, you might be asking: "But we're losing any information on where an error happend!" and that is true. The example can be extended by using an <code>std::expected</code> type instead of <code>std::optional</code> and follow up the chained function calls with <code>.or_else()</code> to handle the error case while maintaining the error context.<h2 id=safety>Safety</h2><p>In his talk <a href=https://cpponsea.uk/2025/session/will-your-program-still-be-correct-next-year rel=external>Will your program still be correct next year?</a> by Björn Fahller, he shared years of experience in writing unit tests and common fallacies.<p>I have now a better understanding that contracts (or assertions, for everyone on older C++ standards) are a measure to <em>detect defects early</em> with rigorous testing. They should enforce conditions that can never be wrong if the program is logically correct. For performance reasons, the assertions should be disabled as soon as testing is completed.<p>Furthermore, there is an old debate in object oriented programming about how to test private methods of a class. I'm convinced now that the following is a good approach: If the logic is sufficiently simple, private methods should be tested via the public interface of the class. If the logic is more complex, it should be extracted into an own class along with own unit tests. There is no need for making methods public just for the sake of testing, nor for the <code>friend</code> approach.<p>John Lakos dived deeper into safety in his talk <a href=https://cpponsea.uk/2025/session/what-cpp-needs-to-be-safe rel=external>What C++ Needs to be Safe </a>. He defined safety as encompassing <strong>correctness, memory safety, and the absence of undefined behavior (UB)</strong>, noting that memory safety is only one aspect. He emphasized that no single tool can achieve complete safety, illustrating this with a Venn diagram of techniques. These techniques include:<ul><li><strong>Contracts (C++26):</strong> For ensuring correctness.<li><strong>Profiles:</strong> Limiting the language to a "safe" subset, orthogonal to contracts.<li><strong>Law of Exclusivity:</strong> Referencing tools like the Rust borrow checker and Circle compiler.<li><strong>Runtime Enforcement with Ghost Data:</strong> Debug-only data to track runtime conditions.</ul><p>Timur Doumler followed up with his talk <a href=https://cpponsea.uk/2025/session/contracts-safety-and-the-art-of-cat-herding rel=external>Contracts, Safety, and the Art of Cat Herding</a>. He pointed out that "safety" is a vague term, being used very differently depending on context. He identified different categories of safety:<ul><li>Functional Safety<li>Regulator Safety<li>Absence of UB<li>Memory Safety<li>etc.</ul><p>It is crucial to define, what safety one is talking about.<p>He also made a point, that if a program is correct, it must be safe and secure as well, as that is implied by correctness. So correctness can serve as generic goal for software development. Lastly, he encouraged a swiss-cheese approach in the endeavors to achieve safety. Different mechanisms target different aspects of safety, and only combined can achieve the level of safety we'd like to see. In addition to the measures mentioned by John, he added replacing UB by EB or other defined behavior, which is currently taking place in C++26 and beyond.<h2 id=performance>Performance</h2><p>Jason Turner kicked off his talk <a href=https://cpponsea.uk/2025/session/the-power-and-pain-of-hidden-symbols rel=external>The Power and Pain of Hidden Symbols </a> by introducing a peculiarity of Windows library development: Each symbol that should become part of a public API needs to be exported explicitly using <code>__declspec(dllexport)</code>. The same behavior can be achieved on Unix as well, with the compiler flag <code>-fvisibilty=hidden</code>. This prevents any symbols from being visible in the object file, unless declared with <code>__attribute__((visibility("default")))</code>. This not only has an impact on the binary size, but also on performance. If this is combined with link time optimization (<code>-flto</code>), a significant performance increase can be observed. The reason for this is, that the compiler can inline functions that are not public, or optimize them away completely. We're basically equipping the compiler with more information how we're going to use the program, enabling more freedom in optimization.<p>Marcell Juhasz contributed to the performance topic with his talk <a href=https://cpponsea.uk/2025/session/balancing-efficiency-and-flexibility-cost-of-abstractions-in-embedded-systems rel=external>Balancing Efficiency and Flexibility: Cost of Abstractions in Embedded Systems</a>. He showed that C++ is a sane choice for embedded development, despite the criticism about runtime overhead. He showed that zero-cost abstractions work as intended (encapsulation, inheritance, static polymorphism) and with the advances in template metaprogramming and other compile-time functionality (templates, concepts, constexpr, consteval), runtime cost can be eliminated altogether.<h2 id=behavioral-insights>Behavioral Insights</h2><p>Mike Shah & Chris Croft-White showed in their talk <a href=https://cpponsea.uk/2025/session/understanding-large-and-unfamiliar-codebases rel=external>Understanding large and unfamiliar codebases</a> approaches to gain insights into unfamiliar code. They highlighted to always start off with the <code>main</code> function and demonstrated tools like <code>gcc</code>, <code>perf</code> and <code>valgrind</code> to navigate through the code rather than reading it in your IDE. The audience also mentioned modern IDEs will build call hierarchies for you.<p>Tina Ulbrich & Hendrik Niemeyer raised awareness of environmental factors in their talk <a href=https://cpponsea.uk/2025/session/green-programming rel=external>Green Programming</a>. They showed what metrics affect energy consumption in the software world, and how to make smart decisions when environmental considerations should be taken into account. C++, C and Rust are great choices for environmentally friendly languages, as the main contributing factor for energy consumption seems to be runtime. Also, it matters where the code is physically run, e.g. in Norway, where 88% of energy originates from hydroelectricity, or in the US, where well over 50% of energy is still generated via fossil resources.<p>In Timur Doumler's talk (mentioned above under "Safety"), he also mentioned an interesting way that he is implementing in the WG21 to discuss approaches and achieve consensus, which he calls "THE TABLE". That is a table that lists different options in its columnds, and requirements or qualities in its rows.<table><thead><tr><th><th>Approach 1<th>Approach 2<th>Approach 3<tbody><tr><td>Requirement 1<td>❌<td>✅<td>❌<tr><td>Requirement 2<td>✅<td>⚠️ Only, if ...<td>❌<tr><td>Requirement 3<td>✅<td>✅<td>✅</table><p>THE TABLE helps to get everyone on the same page for a discussion, which is often the biggest challenge. Also, solutions get more obvious.<p>Last but not least, Kristen Shaker ended the conference with her talk <a href=https://cpponsea.uk/2025/session/why-software-engineering-interviews-are-broken-and-how-to-actually-make-them-better rel=external> Why Software Engineering Interviews are Broken and How to Actually Make them Better</a>. She demonstrated how technical interviews consisting of leetcode or hackerrank problems don't lead to good hires, but companies are still widely relying on that. Many engineers admit that if interviewed today, they would fail their technical interviews, since everyday work is very different and requires a different set of skills as interviews do. Instead, interviews should consist of questions that have many right answers, like<blockquote><p>What is your favorite feature of C++ and how have you used it in the past?</blockquote><p>This is an open question that is easy to answer for anyone with a certain C++ experience, but difficult to answer without having used C++.<h2 id=personal-takeaways>Personal Takeaways</h2><p>Two unrelated notes that I took:<ul><li>Invest heavily in your tooling, both hardware and software<li>Take a step back from daily business and focus more on fundamental questions</ul><h2 id=ending-notes>Ending Notes</h2><p>Who I didn't mention above, but still want to mention, are Mantrala Sandeep and Walter E Brown, who gave a great refresher on C++ value categories.<p>Thanks to Phil and all the volunteers and speakers for the great conference!</section></article></main></div><hr><center><small>Copyright © 2026 Sebastian Müller. All rights reserved.</small></center></div><div class=right-content></div>