<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://sbmueller.github.io/ name=base><title>
            
                Mocking the Right Way in C++
            
        </title><meta content="Mocking the Right Way in C++" property=og:title><link href=https://sbmueller.github.io/icon/favicon.png rel=icon type=image/png><link href=https://sbmueller.github.io/fonts.css rel=stylesheet><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://sbmueller.github.io/theme/light.css rel=stylesheet><link href=https://sbmueller.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://sbmueller.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://sbmueller.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><style>.avatar{vertical-align:middle;border-radius:50%;max-width:150px;height:auto}#wrapper{clear:both;text-align:center;width:100%}</style><nav><div class=left-nav><a href=https://sbmueller.github.io/>sbmueller</a><div class=socials><a class=social href=https://github.com/sbmueller/ rel=me> <img alt=github src=https://sbmueller.github.io/icons/social/github.svg> </a><a class=social href=https://www.linkedin.com/in/sbmueller/ rel=me> <img alt=linkedin src=https://sbmueller.github.io/icons/social/linkedin.svg> </a></div></div><div class=right-nav><a href=https://sbmueller.github.io/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://sbmueller.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://sbmueller.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div id=wrapper><a href=https://sbmueller.github.io/> <img src="https://avatars.githubusercontent.com/u/7465688?v=4" class=avatar> </a></div><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Mocking the Right Way in C++</div><div class=meta>Posted on <time>2025-07-05</time></div></div><section class=body><p>Testing is important. I think every software developer would agree on that. But what ways are there to improve software testing? What if a system is too complex to be simply unit tested with pre-determined inputs and checking its outputs? What if the outputs only take place on a serial bus or with an HTTP request?<blockquote><p>Well, we don't have any way to test this, then.</blockquote><p>I've heard that before. But this is where mocks come in to play!<p>Mocks are objects that are doubles of objects used within a business logic, providing the same interface and looking identical from the outside. But internally, their only purpose is to perform checks how they are "used" in the context of testing. Ideally, a framework like <a href=https://google.github.io/googletest/reference/mocking.html>googlemock</a> is used to get fine control over<ul><li>Which functions are called<li>How often they are called<li>In what order they are called<li>What data shall be passed to them<li>What they should return</ul><p>This way, it can get fairly easy to test complex systems as well, using dependency injection to "smuggle" the mock object instead of the real deal into a business logic.<p>I've seen an approach leveraging dynamic polymorphism before, that I want to review, and then come up with a better solution.<h1 id=a-difficult-class-to-test>A Difficult Class to Test</h1><p>First of all, let's start with a <code>Serial</code> class that represents a serial bus, or a similar hardware abstraction.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>Serial </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>open_serial</span><span>()  {
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to open the serial bus
</span><span>        std::cout << </span><span style=color:#98c379>"Bus open</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>send_data</span><span>(std::span<</span><span style=color:#c678dd>const</span><span> std::uint8_t> </span><span style=color:#e06c75>data</span><span>)  {
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to send the data over the bus
</span><span>        (</span><span style=color:#c678dd>void</span><span>)data;
</span><span>        std::cout << </span><span style=color:#98c379>"Data sent over bus</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>};
</span></code></pre><p>Now, assume there is object we want to test, <code>UnitUnderTest</code>, that makes use of the <code>Serial</code> class.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>UnitUnderTest </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#61afef>UnitUnderTest</span><span>() = </span><span style=color:#c678dd>default</span><span>;
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>work</span><span>() </span><span style=color:#c678dd>const </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// Actual business logic
</span><span>        std::array&LTuint8_t, </span><span style=color:#d19a66>127</span><span>> </span><span style=color:#e06c75>data</span><span>{</span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>7</span><span>};
</span><span>        serial_.</span><span style=color:#e06c75>open_serial</span><span>();
</span><span>        serial_.</span><span style=color:#e06c75>send_data</span><span>(std::</span><span style=color:#e06c75>span</span><span><</span><span style=color:#c678dd>const</span><span> std::uint8_t>(data.</span><span style=color:#e06c75>data</span><span>(), </span><span style=color:#d19a66>4</span><span>));
</span><span>    }
</span><span style=color:#c678dd>private</span><span>:
</span><span>    Serial serial_;
</span><span>};
</span></code></pre><p>This object has a <code>work</code> function that sends data over the serial bus, which is accessed via the <code>serial_</code> member of the class.<p>Now the crucial question: How to write a test for the <code>UnitUnderTest</code> class? The <code>work</code> method returns <code>void</code> and calls methods of the <code>Serial</code> class. There is nothing that we can observe from the outside of this class to understand what happens internally.<h1 id=mocking-with-dynamic-polymorphism>Mocking with Dynamic Polymorphism</h1><p>As outlined above, let's create a mock object of <code>Serial</code> for testing purposes, that checks if the calls to it were made correctly. When using dynamic polymorphism, a common abstract base class (or interface) is created that specifies the interface of any <code>Serial</code> implementation:<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>ISerial </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#c678dd>virtual void </span><span style=color:#61afef>open_serial</span><span>() = </span><span style=color:#d19a66>0</span><span>;
</span><span>    </span><span style=color:#c678dd>virtual void </span><span style=color:#61afef>send_data</span><span>(std::span<</span><span style=color:#c678dd>const</span><span> std::uint8_t> </span><span style=color:#e06c75>data</span><span>) = </span><span style=color:#d19a66>0</span><span>;
</span><span>};
</span></code></pre><p>Next, the <code>Serial</code> class needs to inherit from this interface.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>Serial </span><span>: </span><span style=color:#c678dd>public </span><span style=color:#98c379>ISerial </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>open_serial</span><span>() </span><span style=color:#c678dd>override </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to open the serial bus
</span><span>        std::cout << </span><span style=color:#98c379>"Bus open</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>send_data</span><span>(std::span<</span><span style=color:#c678dd>const</span><span> std::uint8_t> </span><span style=color:#e06c75>data</span><span>) </span><span style=color:#c678dd>override </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to send the data over the bus
</span><span>        (</span><span style=color:#c678dd>void</span><span>)data;
</span><span>        std::cout << </span><span style=color:#98c379>"Data sent over bus</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>};
</span></code></pre><p>On a site note, see that the <code>override</code> keyword was added to make sure that these methods actually override a virtual method in the base class, which is a good way to catch bugs.<p>Next, we have to implement a mock serial object that implements the <code>ISerial</code> interface.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>SerialMock </span><span>: </span><span style=color:#c678dd>public </span><span style=color:#98c379>ISerial </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>open_serial</span><span>() </span><span style=color:#c678dd>override </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to check number of calls to this function, etc.
</span><span>        std::cout << </span><span style=color:#98c379>"SerialMock open_serial()</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>send_data</span><span>(std::span<</span><span style=color:#c678dd>const</span><span> std::uint8_t> </span><span style=color:#e06c75>data</span><span>) </span><span style=color:#c678dd>override </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to check number of calls to this function, etc.
</span><span>        std::cout << </span><span style=color:#98c379>"SerialMock send_data()</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>};
</span></code></pre><p>Note that this is just an example, ideally this would leverage a mocking framework as outlined in the introduction.<p>Lastly, we need to make <code>UnitUnderTest</code> use different derived classes of <code>ISerial</code>, determined dynamically at runtime:<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>UnitUnderTest </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#5c6370;font-style:italic>// Dependency injection via reference
</span><span>    </span><span style=color:#61afef>UnitUnderTest</span><span>(ISerial& </span><span style=color:#e06c75>serial</span><span>) : </span><span style=color:#e06c75>serial_</span><span>(serial) {};
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>work</span><span>() </span><span style=color:#c678dd>const </span><span>{
</span><span>        </span><span style=color:#5c6370;font-style:italic>// Actual business logic
</span><span>        std::array&LTuint8_t, </span><span style=color:#d19a66>127</span><span>> </span><span style=color:#e06c75>data</span><span>{</span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>7</span><span>};
</span><span>        serial_.</span><span style=color:#e06c75>open_serial</span><span>();
</span><span>        serial_.</span><span style=color:#e06c75>send_data</span><span>(std::</span><span style=color:#e06c75>span</span><span><</span><span style=color:#c678dd>const</span><span> std::uint8_t>(data.</span><span style=color:#e06c75>data</span><span>(), </span><span style=color:#d19a66>4</span><span>));
</span><span>    }
</span><span style=color:#c678dd>private</span><span>:
</span><span>    ISerial& serial_;
</span><span>};
</span></code></pre><p>Before we review this approach, let's look at the usage of the class in the business logic and in tests.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#5c6370;font-style:italic>// Business logic case
</span><span>Serial serial; </span><span style=color:#5c6370;font-style:italic>// Note that lifetime needs to be managed outside UnitUnderTest!
</span><span>UnitUnderTest </span><span style=color:#61afef>business</span><span>(</span><span style=color:#e06c75>serial</span><span>);
</span><span>business.</span><span style=color:#e06c75>work</span><span>();
</span><span>
</span><span style=color:#5c6370;font-style:italic>// Test case
</span><span>SerialMock serial_mock; </span><span style=color:#5c6370;font-style:italic>// Note that lifetime needs to be managed outside UnitUnderTest!
</span><span>UnitUnderTest </span><span style=color:#61afef>test</span><span>(</span><span style=color:#e06c75>serial_mock</span><span>);
</span><span>test.</span><span style=color:#e06c75>work</span><span>();
</span></code></pre><p>The full example can be found <a href=https://godbolt.org/z/8xj6nrYG1>here</a>.<p>We can make the following observations:<ul><li>We have to extend the constructor of <code>UnitUnderTest</code> with an additional parameter for dynamic dependency injection<li>The lifetime of the <code>ISerial</code> implementation needs to be managed <em>outside</em> the <code>UnitUnderTest</code> class<li>The usage of <code>UnitUnderTest</code> becomes cumbersome; developers usually would expect to construct the class without arguments, but with this approach they have to think about the dependency injection due to mocking even outside of test scenarios<li>Dynamic polymorphism has an impact on runtime</ul><p>Overall, that doesn't look too great. Let's try a better approach next, leveraging static polymorphism.<h1 id=mocking-with-static-polymorphism>Mocking with Static Polymorphism</h1><p>Let's assume the same starting point as in the first section.<p>First, we create a <code>SerialMock</code> object without defining an interface first.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>class </span><span style=color:#e5c07b>SerialMock </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>open_serial</span><span>() {
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to check number of calls to this function, etc.
</span><span>        std::cout << </span><span style=color:#98c379>"SerialMock open_serial()</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>send_data</span><span>(std::span<</span><span style=color:#c678dd>const</span><span> std::uint8_t> </span><span style=color:#e06c75>data</span><span>) {
</span><span>        </span><span style=color:#5c6370;font-style:italic>// ... logic to check number of calls to this function, etc.
</span><span>        std::cout << </span><span style=color:#98c379>"SerialMock send_data()</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>"</span><span>;
</span><span>    }
</span><span>};
</span></code></pre><p>Next, instead of leveraging dynamic polymorphism via a constructor argument, we change the <code>UnitUnderTest</code> class to become a class template.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>template</span><span><</span><span style=color:#c678dd>class</span><span> SerialType> </span><span style=color:#5c6370;font-style:italic>// Static Polymorhism
</span><span style=color:#c678dd>class </span><span style=color:#e5c07b>UnitUnderTestTemplate </span><span>{
</span><span style=color:#c678dd>public</span><span>:
</span><span>    </span><span style=color:#61afef>UnitUnderTestTemplate</span><span>() = </span><span style=color:#c678dd>default</span><span>;
</span><span>    </span><span style=color:#c678dd>void </span><span style=color:#61afef>work</span><span>() {
</span><span>        </span><span style=color:#5c6370;font-style:italic>// Actual business logic
</span><span>        std::array&LTuint8_t, </span><span style=color:#d19a66>127</span><span>> </span><span style=color:#e06c75>data</span><span>{</span><span style=color:#d19a66>1</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>3</span><span>, </span><span style=color:#d19a66>7</span><span>};
</span><span>        serial_.</span><span style=color:#e06c75>open_serial</span><span>();
</span><span>        serial_.</span><span style=color:#e06c75>send_data</span><span>(std::</span><span style=color:#e06c75>span</span><span><</span><span style=color:#c678dd>const</span><span> std::uint8_t>(data.</span><span style=color:#e06c75>data</span><span>(), </span><span style=color:#d19a66>4</span><span>));
</span><span>    }
</span><span style=color:#c678dd>private</span><span>:
</span><span>    SerialType serial_;
</span><span>};
</span></code></pre><p>A class template is an instruction outlining how to instantiate concrete class definitions at compile time. This allows us to let the compiler generate in fact two classes for us: One with the mocked serial object, and one with the actual one for usage in the business logic.<p>Without an interface, how can we make sure that the mock object implements the same interface as the original object? I would argue, since we use both objects the same way in <code>UnitUnderTest</code>, we enforce that they can be treated the same way at compile time. If we would miss a method in the mock class that we actually use in <code>UnitUnderTest</code>, the compilation would fail. Basically, the business logic becomes the specification of which interface must be implemented. Also, in C++20 or later, <a href=https://en.cppreference.com/w/cpp/language/constraints.html>concepts</a> can be used to pose restrictions on template arguments, but that's out of scope for this article.<p>To improve the usage, I renamed the class template and will add a type alias with the original name.<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>using </span><span>UnitUnderTest = UnitUnderTestTemplate&LTSerial>;
</span></code></pre><p>This completely eliminates having to think about mocking when using the class. The usage looks like this:<pre class=language-cpp data-lang=cpp style=color:#abb2bf;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#5c6370;font-style:italic>// Note that Serial lifetime is managed internally
</span><span style=color:#5c6370;font-style:italic>// Note the nice ergonomics - no constructor argument necessary, just use the class while ignoring any mocking here
</span><span>UnitUnderTest business;
</span><span>business.</span><span style=color:#e06c75>work</span><span>();
</span><span>
</span><span style=color:#5c6370;font-style:italic>// Test case
</span><span>UnitUnderTestTemplate&LTSerialMock> test;
</span><span>test.</span><span style=color:#e06c75>work</span><span>();
</span></code></pre><p>The full example is <a href=https://godbolt.org/z/cPc6MK7WE>here</a>.<p>Let's review this approach:<ul><li>The lifetime of the <code>Serial</code> object is managed internally in <code>UnitUnderTest</code>; exactly like it was before introducing the mock<li>The constructor takes the same arguments as before as well, no additional parameters<li>Due to the type alias, usage of the <code>UnitUnderTest</code> class is as developers would expect it; just instantiate it without any thoughts of mocking<li>In a test scenario, use the template explicitly to create a class containing a mocked object<li>Static polymorphism doesn't add any runtime overhead</ul></section></article></main></div><hr><center><small>Copyright © 2025 Sebastian Müller. All rights reserved.</small></center></div><div class=right-content></div>